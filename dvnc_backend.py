#!/usr/bin/env python3
"""
DVNC.AI Interactive - Da Vinci-Inspired Product Design System (Set Prompts Variant)
---------------------------------------------------------------------------------
An interactive version where users must enter one of the predefined set prompts. The system validates the input,
mimics three SLMs for knowledge verticals based on da Vinci's domains, synthesizes via the Da Vinci Abstraction Organ,
and provides a detailed finished product description. Enhanced with additional insights from da Vinci's works.
"""

import random
import re
from dataclasses import dataclass
from typing import List, Tuple
from enum import Enum

# ---------- Core Data Structures ----------

class DevelopmentStage(Enum):
    """Stages of technical readiness for a design feature."""
    CONCEPT = 1
    PROTOTYPE = 2
    PRODUCTION_READY = 3

@dataclass
class DesignFeature:
    """A specific, actionable feature of a product design."""
    description: str
    inspiration: str  # Direct quote or concept from da Vinci's work
    development_stage: DevelopmentStage
    engineering_notes: str

@dataclass
class DesignCandidate:
    """Represents a commercially viable design candidate generated by the system."""
    name: str
    product_type: str
    core_innovation: str
    features: List[DesignFeature]
    target_market: str
    innovation_score: int  # 1-10 scale
    feasibility_score: int  # 1-10 scale
    viability_score: float  # 0-1.0
    da_vinci_principles: List[str]

# ---------- Enhanced Grouped Knowledge Verticals for SLMs (With Additional Quotes) ----------

def get_mechanics_physics_insights() -> List[Tuple[str, str]]:
    """Insights for Mechanics & Physics SLM, enhanced with more quotes."""
    return [
        ("Pyramidal law of force: power diminishes towards its end.", "Madrid I, 16r - Studies of spring mechanics"),
        ("Water seeks the most efficient path; design channels to guide flow, not resist it.", "Codex Leicester - Studies of water vortices"),
        ("Structural efficiency through geometric forms and arches.", "Studies of architecture and the Tiburio of Milan Cathedral"),
        ("Use of worm gears and stable axle bearings for compact power transmission.", "Madrid I - Codice Atlantico mechanical studies"),
        ("Squaring the circle: geometric transformations for equivalence.", "Madrid Codices - Geometry"),
        ("Pyramidal forms for perspective and force distribution.", "Treatise on Painting - Perspective"),
        ("Water in motion forms vortices that concentrate force.", "Codex Leicester - Water studies"),
        ("Motion is the cause of every life.", "Trattato della Pittura - On motion"),
        ("Mechanics is the paradise of the mathematical sciences, because by means of it one comes to the fruits of mathematics.", "Notebook E"),
        ("Instrumental or mechanical science is the noblest and, above all others, the most useful.", "Unknown"),
        ("There is no result in nature without a cause; understand the cause and you will have no need of the experiment.", "Unknown"),
        ("Force is an immaterial power, an invisible potency which is created and infused.", "Unknown"),
        ("The force of the mover ought to be always in proportion to the weight of the whole mobile object and to the resistance of the medium in which the object moves.", "Unknown"),
    ]

def get_anatomy_biology_insights() -> List[Tuple[str, str]]:
    """Insights for Anatomy & Biology SLM, enhanced with more quotes."""
    return [
        ("The nerve chords serve the sensus communis as the officers serve their captain.", "W.19019r - Anatomical studies of the brain"),
        ("Proportional harmony based on the Vitruvian system.", "Venice Accademia - Proportional Study of a Man"),
        ("Layered system integration (like muscle, tendon, bone).", "Anatomical drawings - Cross Sections of the Human Skull"),
        ("Study bird anatomy for biomimetic flight devices.", "Windsor Manuscripts - Anatomy of birds"),
        ("Proportions of the human figure dictate balance and harmony.", "Codex Atlanticus - Vitruvian Man studies"),
        ("Superficial anatomy reveals the underlying structure for natural poses.", "Windsor Manuscripts - Surface anatomy studies"),
        ("Wings must beat downwards and backwards for lift.", "Codex Atlanticus - Flying machine"),
        ("Bird flight relies on compressed air under wings.", "Windsor Manuscripts - Bird studies"),
        ("Learn from nature: that is where our future lies.", "Unknown"),
        ("Nature is the source of all true knowledge.", "Unknown"),
        ("The human foot is a masterpiece of engineering and a work of art.", "Unknown"),
        ("The soul is content to stay imprisoned in the human body... for through the eyes all the various things of nature are represented to the soul.", "Unknown"),
    ]

def get_optics_aesthetics_insights() -> List[Tuple[str, str]]:
    """Insights for Optics & Aesthetics SLM, enhanced with more quotes."""
    return [
        ("Shadow is of greater power than light... light can never chase away all the shadows.", "Ash.II, 21r - Treatise on Painting"),
        ("Sfumato: do not make definite or sharp boundaries because your work will have a wooden quality.", "Ash.II, 14v - Treatise on Painting"),
        ("Use contrast (light/dark) to emphasize important elements and create depth.", "Study of Light and Shade on a Tree - Windsor 12431v"),
        ("Atmospheric perspective: distant objects lose clarity and color saturation.", "Background of the Mona Lisa and Madonna of the Rocks"),
        ("Let materials express their natural properties rather than forcing them.", "Studies of geological formations and plant structures"),
        ("Design for graceful aging and patina development.", "Observations of ancient Roman bronzes and buildings"),
        ("Golden ratio in natural and man-made designs.", "Paciolian influences - Divine Proportion"),
        ("Among all the studies of natural causes and reasons, light most delights the contemplators.", "Manuscript on optics"),
        ("Darkness is absence of light. Shadow is diminution of light.", "Unknown"),
        ("The beginnings and ends of shadow lie between the light and darkness and may be infinitely diminished and infinitely increased. Shadow is the means by which bodies display their form.", "Unknown"),
        ("Shadow is not the absence of light, merely the obstruction of the luminous rays by an opaque body. Shadow is of the nature of darkness.", "Unknown"),
        ("Light is the expeller of darkness. Shadow is the suppression of light.", "Unknown"),
    ]

# ---------- SLM Mimic Functions ----------

def mechanics_physics_slm(product_type: str) -> List[Tuple[str, str]]:
    """Mechanics & Physics SLM: Generates 2-3 feature ideas tailored to the product_type."""
    insights = get_mechanics_physics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Apply {concept.split(':')[0].lower().strip()} to enhance mechanical efficiency and durability in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    print(f"\n--- Mechanics & Physics SLM Output for '{product_type}' ---")
    for desc, insp in features:
        print(f"  • {desc}\n    (Inspiration: {insp})")
    return features

def anatomy_biology_slm(product_type: str) -> List[Tuple[str, str]]:
    """Anatomy & Biology SLM: Generates 2-3 feature ideas tailored to the product_type."""
    insights = get_anatomy_biology_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Incorporate {concept.split(':')[0].lower().strip()} for biomimetic ergonomics and user comfort in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    print(f"\n--- Anatomy & Biology SLM Output for '{product_type}' ---")
    for desc, insp in features:
        print(f"  • {desc}\n    (Inspiration: {insp})")
    return features

def optics_aesthetics_slm(product_type: str) -> List[Tuple[str, str]]:
    """Optics & Aesthetics SLM: Generates 2-3 feature ideas tailored to the product_type."""
    insights = get_optics_aesthetics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Integrate {concept.split(':')[0].lower().strip()} for visual harmony and aesthetic appeal in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    print(f"\n--- Optics & Aesthetics SLM Output for '{product_type}' ---")
    for desc, insp in features:
        print(f"  • {desc}\n    (Inspiration: {insp})")
    return features

# ---------- Da Vinci Abstraction Organ: Synthesis ----------

def da_vinci_abstraction_organ(product_type: str, slm_outputs: List[List[Tuple[str, str]]]) -> List[DesignFeature]:
    """Synthesizes outputs from the 3 SLMs into 4-6 cohesive features."""
    all_ideas = [idea for slm in slm_outputs for idea in slm]
    selected_ideas = random.sample(all_ideas, k=random.randint(4, 6))
    features = []
    for desc, inspiration in selected_ideas:
        stage_weights = [(.15, DevelopmentStage.CONCEPT), (.45, DevelopmentStage.PROTOTYPE), (.4, DevelopmentStage.PRODUCTION_READY)]
        weights, stages = zip(*stage_weights)
        stage = random.choices(stages, weights=weights, k=1)[0]

        if stage == DevelopmentStage.CONCEPT:
            note = "Conceptual exploration; requires validation through modeling and testing."
        elif stage == DevelopmentStage.PROTOTYPE:
            note = "Prototype feasible with current technology; refine through user feedback and iteration."
        else:
            note = "Production-ready using established scalable manufacturing processes."

        features.append(DesignFeature(description=desc, inspiration=inspiration, development_stage=stage, engineering_notes=note))

    print(f"\n--- Da Vinci Abstraction Organ: Synthesis for '{product_type}' ---")
    for i, feat in enumerate(features, 1):
        print(f"  {i}. {feat.description} (Stage: {feat.development_stage.name}, Notes: {feat.engineering_notes})")
    return features

# ---------- Scoring and Candidate Generation ----------

def score_innovation(features: List[DesignFeature]) -> int:
    stage_weights = {DevelopmentStage.CONCEPT: 3, DevelopmentStage.PROTOTYPE: 3, DevelopmentStage.PRODUCTION_READY: 2}
    total = sum(stage_weights[f.development_stage] for f in features)
    normalized = (total / (len(features) * 3)) * 10
    return max(7, min(10, int(normalized + random.uniform(-1, 2))))

def score_feasibility(features: List[DesignFeature]) -> int:
    stage_weights = {DevelopmentStage.CONCEPT: 1, DevelopmentStage.PROTOTYPE: 3, DevelopmentStage.PRODUCTION_READY: 3}
    total = sum(stage_weights[f.development_stage] for f in features)
    normalized = (total / (len(features) * 3)) * 10
    return max(7, min(10, int(normalized + random.uniform(-1, 2))))

def calculate_viability(innovation: int, feasibility: int, market: str) -> float:
    base_score = (innovation * 0.4) + (feasibility * 0.6)
    base_score /= 10
    market_factor = random.uniform(0.95, 1.1)
    return min(1.0, base_score * market_factor)

def generate_design_candidate(product_type: str, features: List[DesignFeature]) -> DesignCandidate:
    target_market = random.choice(["Consumer Electronics", "Industrial Equipment", "Medical Devices", "Sustainable Goods", "Home Appliances", "Wearables", "Professional Tools"])
    innovation = score_innovation(features)
    feasibility = score_feasibility(features)
    viability = calculate_viability(innovation, feasibility, target_market)
    principles = ["Mechanics & Physics", "Anatomy & Biology", "Optics & Aesthetics"]
    name = f"Vitruvian {random.choice(['Harmony', 'Flow', 'Aero', 'Sfumato'])} {product_type.split()[0].capitalize()}"

    return DesignCandidate(
        name=name,
        product_type=product_type,
        core_innovation="Synthesized via Da Vinci Abstraction Organ from multi-domain SLMs for holistic innovation.",
        features=features,
        target_market=target_market,
        innovation_score=innovation,
        feasibility_score=feasibility,
        viability_score=viability,
        da_vinci_principles=principles,
    )

# ---------- Interactive Main with Set Prompts Validation ----------

def main():
    print("DVNC.AI Interactive - Set Prompts Variant")
    print("=" * 60)
    print("You must enter one of the following predefined prompts exactly as shown.")
    print("Available prompts:")
    set_prompts = [
        "a next-generation ergonomic computer mouse",
        "an innovative kitchen kettle for urban living",
        "a modular laptop docking station",
        "a patient monitoring device for hospitals",
        "a precision gardening tool system",
        "a sustainable packaging solution for electronics",
        "a smart home lighting system",
        "an eco-friendly water bottle",
        "a wearable fitness tracker",
        "a compact urban bicycle",
    ]
    for prompt in set_prompts:
        print(f"  - {prompt}")
    print("\nType 'quit' to exit.\n")

    while True:
        prompt = input("Enter a prompt: ").strip()
        if prompt.lower() == 'quit':
            break
        if prompt not in set_prompts:
            print("Invalid prompt. Please enter one of the listed prompts exactly.")
            continue

        product_type = re.sub(r'^(a|an|the)\s+', '', prompt.lower())

        # Reasoning Steps: Run SLMs
        slm1 = mechanics_physics_slm(product_type)
        slm2 = anatomy_biology_slm(product_type)
        slm3 = optics_aesthetics_slm(product_type)
        all_slm_outputs = [slm1, slm2, slm3]

        # Reasoning Steps: Synthesize
        features = da_vinci_abstraction_organ(product_type, all_slm_outputs)

        # Generate candidate
        candidate = generate_design_candidate(product_type, features)

        # Final Answer: Display candidate and finished product description
        print(f"\n--- Final Design Candidate for '{prompt}' ---")
        print(f"DESIGN: {candidate.name}")
        print(f"Market: {candidate.target_market}")
        print(f"Principles: {', '.join(candidate.da_vinci_principles)}")
        print(f"Innovation: {candidate.innovation_score}/10 | Feasibility: {candidate.feasibility_score}/10 | Viability: {candidate.viability_score:.2f}")
        print("\nKEY FEATURES:")
        for feat in candidate.features:
            print(f"  • {feat.description}")
            print(f"    Inspiration: {feat.inspiration}")
            print(f"    Readiness: {feat.development_stage.name} - {feat.engineering_notes}")

        # Finished Product Description
        print("\nFinished Product Description:")
        print(f"The {candidate.name} revolutionizes the {candidate.product_type} category for {candidate.target_market} users.")
        print("Drawing from da Vinci's genius, it seamlessly blends mechanical precision, biological inspiration, and aesthetic elegance.")
        for feat in candidate.features:
            print(f" It incorporates {feat.description.lower()}, inspired by {feat.inspiration.split('||')[0].strip()}, currently at {feat.development_stage.name.lower()} stage ({feat.engineering_notes.lower()}).")
        print(f"This design not only scores {candidate.innovation_score}/10 in innovation but also {candidate.feasibility_score}/10 in feasibility, yielding a strong viability of {candidate.viability_score:.2f}.")
        print(f"Imagine a product that feels like an extension of nature itself—durable, intuitive, and beautifully crafted for everyday use.\n")
        print("=" * 60 + "\n")

if __name__ == "__main__":
    main()
