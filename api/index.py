#!/usr/bin/env python3
"""
Vercel Serverless Function for DVNC.AI
This should be placed at api/index.py in your repository
"""

from http.server import BaseHTTPRequestHandler
import json
import random
import re
from dataclasses import dataclass, asdict
from typing import List, Tuple
from enum import Enum

# ---------- Core Data Structures ----------

class DevelopmentStage(Enum):
    """Stages of technical readiness for a design feature."""
    CONCEPT = 1
    PROTOTYPE = 2
    PRODUCTION_READY = 3

@dataclass
class DesignFeature:
    """A specific, actionable feature of a product design."""
    description: str
    inspiration: str
    development_stage: DevelopmentStage
    engineering_notes: str

@dataclass
class DesignCandidate:
    """Represents a commercially viable design candidate generated by the system."""
    name: str
    product_type: str
    core_innovation: str
    features: List[DesignFeature]
    target_market: str
    innovation_score: int
    feasibility_score: int
    viability_score: float
    da_vinci_principles: List[str]

# ---------- Knowledge Verticals ----------

def get_mechanics_physics_insights() -> List[Tuple[str, str]]:
    """Insights for Mechanics & Physics SLM."""
    return [
        ("Pyramidal law of force: power diminishes towards its end.", "Madrid I, 16r - Studies of spring mechanics"),
        ("Water seeks the most efficient path; design channels to guide flow, not resist it.", "Codex Leicester - Studies of water vortices"),
        ("Structural efficiency through geometric forms and arches.", "Studies of architecture and the Tiburio of Milan Cathedral"),
        ("Use of worm gears and stable axle bearings for compact power transmission.", "Madrid I - Codice Atlantico mechanical studies"),
        ("Motion is the cause of every life.", "Trattato della Pittura - On motion"),
        ("Mechanics is the paradise of the mathematical sciences.", "Notebook E"),
    ]

def get_anatomy_biology_insights() -> List[Tuple[str, str]]:
    """Insights for Anatomy & Biology SLM."""
    return [
        ("The nerve chords serve the sensus communis as the officers serve their captain.", "W.19019r - Anatomical studies of the brain"),
        ("Proportional harmony based on the Vitruvian system.", "Venice Accademia - Proportional Study of a Man"),
        ("Layered system integration (like muscle, tendon, bone).", "Anatomical drawings - Cross Sections of the Human Skull"),
        ("Study bird anatomy for biomimetic flight devices.", "Windsor Manuscripts - Anatomy of birds"),
        ("Learn from nature: that is where our future lies.", "Unknown"),
        ("The human foot is a masterpiece of engineering and a work of art.", "Unknown"),
    ]

def get_optics_aesthetics_insights() -> List[Tuple[str, str]]:
    """Insights for Optics & Aesthetics SLM."""
    return [
        ("Shadow is of greater power than light.", "Ash.II, 21r - Treatise on Painting"),
        ("Sfumato: do not make definite boundaries.", "Ash.II, 14v - Treatise on Painting"),
        ("Use contrast (light/dark) to emphasize important elements.", "Study of Light and Shade - Windsor 12431v"),
        ("Atmospheric perspective: distant objects lose clarity.", "Background of the Mona Lisa"),
        ("Golden ratio in natural and man-made designs.", "Paciolian influences - Divine Proportion"),
        ("Light is the expeller of darkness.", "Unknown"),
    ]

# ---------- SLM Functions ----------

def mechanics_physics_slm(product_type: str) -> List[Tuple[str, str]]:
    """Mechanics & Physics SLM."""
    insights = get_mechanics_physics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Apply {concept.split(':')[0].lower().strip()} to enhance mechanical efficiency in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    return features

def anatomy_biology_slm(product_type: str) -> List[Tuple[str, str]]:
    """Anatomy & Biology SLM."""
    insights = get_anatomy_biology_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Incorporate {concept.split(':')[0].lower().strip()} for biomimetic ergonomics in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    return features

def optics_aesthetics_slm(product_type: str) -> List[Tuple[str, str]]:
    """Optics & Aesthetics SLM."""
    insights = get_optics_aesthetics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Integrate {concept.split(':')[0].lower().strip()} for visual harmony in the {product_type}."
        features.append((desc, f"{concept} || Source: {source}"))
    return features

def da_vinci_abstraction_organ(product_type: str, slm_outputs: List[List[Tuple[str, str]]]) -> List[DesignFeature]:
    """Synthesizes outputs from the 3 SLMs."""
    all_ideas = [idea for slm in slm_outputs for idea in slm]
    selected_ideas = random.sample(all_ideas, k=min(len(all_ideas), random.randint(4, 6)))
    features = []
    
    for desc, inspiration in selected_ideas:
        stage_weights = [(.15, DevelopmentStage.CONCEPT), (.45, DevelopmentStage.PROTOTYPE), (.4, DevelopmentStage.PRODUCTION_READY)]
        weights, stages = zip(*stage_weights)
        stage = random.choices(stages, weights=weights, k=1)[0]

        if stage == DevelopmentStage.CONCEPT:
            note = "Conceptual exploration; requires validation through modeling and testing."
        elif stage == DevelopmentStage.PROTOTYPE:
            note = "Prototype feasible with current technology; refine through user feedback."
        else:
            note = "Production-ready using established scalable manufacturing processes."

        features.append(DesignFeature(
            description=desc,
            inspiration=inspiration,
            development_stage=stage,
            engineering_notes=note
        ))
    
    return features

def generate_design_candidate(product_type: str, features: List[DesignFeature]) -> DesignCandidate:
    """Generate a design candidate."""
    target_market = random.choice([
        "Consumer Electronics", "Industrial Equipment", "Medical Devices",
        "Sustainable Goods", "Home Appliances", "Wearables", "Professional Tools"
    ])
    
    # Scoring functions
    innovation_score = max(7, min(10, int(random.uniform(7, 10))))
    feasibility_score = max(7, min(10, int(random.uniform(7, 10))))
    viability_score = min(1.0, (innovation_score * 0.4 + feasibility_score * 0.6) / 10 * random.uniform(0.95, 1.1))
    
    principles = ["Mechanics & Physics", "Anatomy & Biology", "Optics & Aesthetics"]
    name = f"Vitruvian {random.choice(['Harmony', 'Flow', 'Aero', 'Sfumato'])} {product_type.split()[0].capitalize()}"
    
    return DesignCandidate(
        name=name,
        product_type=product_type,
        core_innovation="Synthesized via Da Vinci Abstraction Organ for holistic innovation.",
        features=features,
        target_market=target_market,
        innovation_score=innovation_score,
        feasibility_score=feasibility_score,
        viability_score=viability_score,
        da_vinci_principles=principles,
    )

# ---------- API Handler ----------

VALID_PROMPTS = [
    "a next-generation ergonomic computer mouse",
    "an innovative kitchen kettle for urban living",
    "a modular laptop docking station",
    "a patient monitoring device for hospitals",
    "a precision gardening tool system",
    "a sustainable packaging solution for electronics",
    "a smart home lighting system",
    "an eco-friendly water bottle",
    "a wearable fitness tracker",
    "a compact urban bicycle",
]

class handler(BaseHTTPRequestHandler):
    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_GET(self):
        if self.path == '/api/prompts':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            response = {'prompts': VALID_PROMPTS}
            self.wfile.write(json.dumps(response).encode())
        elif self.path == '/api/health':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            response = {'status': 'healthy', 'service': 'DVNC.AI Backend'}
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_error(404)

    def do_POST(self):
        if self.path == '/api/generate':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            
            try:
                data = json.loads(post_data)
                prompt = data.get('prompt', '').strip()
                
                # Validate prompt
                if prompt not in VALID_PROMPTS:
                    self.send_response(400)
                    self.send_header('Content-Type', 'application/json')
                    self.send_header('Access-Control-Allow-Origin', '*')
                    self.end_headers()
                    error_response = {'error': 'Invalid prompt. Please select from the available options.'}
                    self.wfile.write(json.dumps(error_response).encode())
                    return
                
                # Extract product type
                product_type = re.sub(r'^(a|an|the)\s+', '', prompt.lower())
                
                # Run SLMs
                slm1_output = mechanics_physics_slm(product_type)
                slm2_output = anatomy_biology_slm(product_type)
                slm3_output = optics_aesthetics_slm(product_type)
                all_slm_outputs = [slm1_output, slm2_output, slm3_output]
                
                # Synthesize features
                features = da_vinci_abstraction_organ(product_type, all_slm_outputs)
                
                # Generate candidate
                candidate = generate_design_candidate(product_type, features)
                
                # Format response with FULL details
                response = {
                    'name': candidate.name,
                    'product_type': candidate.product_type,
                    'target_market': candidate.target_market,
                    'innovation_score': candidate.innovation_score,
                    'feasibility_score': candidate.feasibility_score,
                    'viability_score': round(candidate.viability_score, 2),
                    'core_innovation': candidate.core_innovation,
                    'da_vinci_principles': candidate.da_vinci_principles,
                    'features': [
                        {
                            'description': f.description,
                            'inspiration': f.inspiration,  # Keep FULL inspiration with source
                            'stage': f.development_stage.name,
                            'notes': f.engineering_notes
                        }
                        for f in candidate.features
                    ],
                    'slm_outputs': {
                        'mechanics': [f"{desc} || {insp}" for desc, insp in slm1_output],  # Include full output
                        'anatomy': [f"{desc} || {insp}" for desc, insp in slm2_output],
                        'optics': [f"{desc} || {insp}" for desc, insp in slm3_output]
                    },
                    'synthesis_count': len(candidate.features),
                    'total_slm_outputs': len(slm1_output) + len(slm2_output) + len(slm3_output)
                }
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
                
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                error_response = {'error': str(e)}
                self.wfile.write(json.dumps(error_response).encode())
        else:
            self.send_error(404)
